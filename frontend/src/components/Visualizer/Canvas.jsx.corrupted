import React, { useState, useEffect, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useTheme } from '../../contexts/ThemeContext';

const Canvas = ({ traceData, stepIndex, setStepIndex }) => {
  const [isPlaying, setIsPlaying] = useState(false);
  const [showRaw, setShowRaw] = useState(false);
  const [previousVariables, setPreviousVariables] = useState({});
  const [collapsedSections, setCollapsedSections] = useState({});

  // üé® Use theme colors
  const { colors, theme } = useTheme();

  // üõ°Ô∏è CRASH GUARD
  if (!traceData || !Array.isArray(traceData) || traceData.length === 0) {
    return (
      <div style={styles.emptyState}>
        <h3 style={{ color: '#888' }}>Waiting for Execution...</h3>
        <p style={{ color: '#666' }}>Run your code to see the visualization here.</p>
      </div>
    );
  }

  // üß† MEMORY ENGINE
  const currentVariables = useMemo(() => {
    let memory = {};

    for (let i = 0; i <= stepIndex; i++) {
      const step = traceData[i];
      if (!step) continue;

      let stepVars = step.variables;
      if (!stepVars) stepVars = step.locals || step.globals;
      if (typeof stepVars === 'string') {
        try { stepVars = JSON.parse(stepVars); } catch (e) { }
      }

      if (stepVars && typeof stepVars === 'object' && Object.keys(stepVars).length > 0) {
        memory = { ...memory, ...stepVars };
      }
    }
    return memory;
  }, [traceData, stepIndex]);

  // üíÖ ENHANCED STYLES (Theme-aware)
  const styles = {
    container: {
      height: '100%',
      display: 'flex',
      flexDirection: 'column',
      background: `linear-gradient(135deg, ${colors.backgroundGradientStart} 0%, ${colors.backgroundGradientEnd} 100%)`,
      color: colors.textPrimary,
      fontFamily: 'Inter, sans-serif'
    },
    emptyState: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100%',
      background: `linear-gradient(135deg, ${colors.backgroundGradientStart} 0%, ${colors.backgroundGradientEnd} 100%)`
    },
    controlBar: {
      padding: '12px 20px',
      background: colors.inputBg,
      backdropFilter: colors.glassBackdrop,
      borderBottom: `1px solid ${colors.divider}`,
    },
    controls: {
      display: 'flex',
      gap: '15px',
      alignItems: 'center'
    },
    button: {
      padding: '8px 15px',
      borderRadius: '8px',
      border: 'none',
      cursor: 'pointer',
      fontSize: '14px',
      fontWeight: '600',
      transition: 'all 0.2s ease-in-out',
      display: 'flex',
      alignItems: 'center',
      gap: '8px',
      background: colors.buttonPrimary,
      color: colors.buttonPrimaryText,
    },
    buttonHover: {
      transform: 'translateY(-1px)',
      boxShadow: '0 4px 10px rgba(0,0,0,0.1)',
    },
    sliderContainer: {
      flexGrow: 1,
      display: 'flex',
      alignItems: 'center',
      gap: '10px',
      margin: '0 20px'
    },
    slider: {
      width: '100%',
      height: '4px',
      background: colors.sliderBg,
      borderRadius: '2px',
      cursor: 'pointer',
      appearance: 'none',
      outline: 'none',
      transition: 'background 0.2s',
    },
    sliderThumb: {
      width: '16px',
      height: '16px',
      background: colors.sliderThumb,
      borderRadius: '50%',
      cursor: 'grab',
      appearance: 'none',
      marginTop: '-6px',
      boxShadow: '0 2px 5px rgba(0,0,0,0.2)',
    },
    stepIndicator: {
      fontSize: '14px',
      fontWeight: '600',
      color: colors.textSecondary
    },
    contentArea: {
      flexGrow: 1,
      padding: '20px',
      overflowY: 'auto',
      display: 'flex',
      flexDirection: 'column',
      gap: '20px',
      position: 'relative',
    },
    section: {
      background: colors.cardBg,
      borderRadius: '12px',
      padding: '15px 20px',
      boxShadow: colors.cardShadow,
      border: `1px solid ${colors.cardBorder}`,
      transition: 'all 0.3s ease',
    },
    sectionHeader: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      cursor: 'pointer',
      marginBottom: '10px',
    },
    sectionTitle: {
      fontSize: '1.2em',
      fontWeight: '700',
      color: colors.textPrimary,
      display: 'flex',
      alignItems: 'center',
      gap: '10px',
    },
    sectionContent: {
      paddingTop: '10px',
      borderTop: `1px solid ${colors.divider}`,
    },
    variablesGrid: {
      display: 'grid',
      gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
      gap: '15px',
    },
    varBox: {
      padding: '12px 15px',
      borderRadius: '10px',
      border: `1px solid ${colors.cardBorder}`,
      display: 'flex',
      flexDirection: 'column',
      gap: '8px',
      transition: 'all 0.3s ease',
      background: colors.inputBg,
    },
    varHeader: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      borderBottom: `1px dashed ${colors.divider}`,
      paddingBottom: '5px',
      marginBottom: '5px',
    },
    varName: {
      fontWeight: '600',
      color: colors.textPrimary,
      fontSize: '1.05em',
    },
    varType: {
      fontSize: '0.8em',
      color: colors.textSecondary,
      background: colors.tagBg,
      padding: '3px 8px',
      borderRadius: '5px',
    },
    varValue: {
      fontFamily: 'monospace',
      fontSize: '0.95em',
      color: colors.textPrimary,
      wordBreak: 'break-word',
    },
    glassEffect: {
      background: colors.glassBg,
      backdropFilter: colors.glassBackdrop,
      boxShadow: colors.glassShadow,
    },
    codeBlock: {
      background: colors.codeBg,
      color: colors.codeText,
      padding: '15px',
      borderRadius: '8px',
      fontFamily: 'monospace',
      whiteSpace: 'pre-wrap',
      wordBreak: 'break-all',
      fontSize: '0.9em',
      border: `1px solid ${colors.codeBorder}`,
    },
    traceLine: {
      padding: '2px 0',
      borderRadius: '3px',
      transition: 'background-color 0.3s ease',
    },
    currentLine: {
      background: colors.highlightBg,
      fontWeight: 'bold',
      color: colors.highlightText,
    },
    treeNode: {
      background: colors.treeNodeBg,
      color: colors.treeNodeText,
      border: `1px solid ${colors.treeNodeBorder}`,
      borderRadius: '8px',
      padding: '8px 12px',
      minWidth: '40px',
      textAlign: 'center',
      fontWeight: '600',
      boxShadow: colors.treeNodeShadow,
      transition: 'all 0.2s ease',
    },
    nullNode: {
      color: colors.textSecondary,
      fontSize: '0.8em',
      opacity: 0.7,
      padding: '5px',
    },
    graphRow: {
      display: 'flex',
      alignItems: 'center',
      gap: '8px',
      background: colors.inputBg,
      padding: '8px 10px',
      borderRadius: '8px',
      border: `1px solid ${colors.divider}`,
    },
    graphNode: {
      background: colors.graphNodeBg,
      color: colors.graphNodeText,
      padding: '5px 10px',
      borderRadius: '6px',
      fontWeight: '600',
      minWidth: '30px',
      textAlign: 'center',
    },
    graphNeighbor: {
      background: colors.graphNeighborBg,
      color: colors.graphNeighborText,
      padding: '4px 8px',
      borderRadius: '5px',
      fontSize: '0.9em',
    },
    enhancedArrayWrapper: {
      padding: '15px',
      borderRadius: '12px',
      border: `1px solid ${colors.cardBorder}`,
      background: colors.cardBg,
      boxShadow: colors.cardShadow,
      transition: 'all 0.3s ease',
      display: 'flex',
      flexDirection: 'column',
      gap: '15px',
    },
    arrayHeader: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      borderBottom: `1px dashed ${colors.divider}`,
      paddingBottom: '10px',
    },
    arrayIcon: {
      fontSize: '1.5em',
    },
    arrayName: {
      fontWeight: '700',
      fontSize: '1.1em',
      color: colors.textPrimary,
    },
    arrayType: {
      fontSize: '0.85em',
      color: colors.textSecondary,
      background: colors.tagBg,
      padding: '4px 10px',
      borderRadius: '6px',
    },
    arrayContent: {
      display: 'flex',
      flexDirection: 'column',
      gap: '10px',
    },
    arrayRow: {
      display: 'flex',
      alignItems: 'center',
      gap: '10px',
      overflowX: 'auto',
      paddingBottom: '5px',
      '&::-webkit-scrollbar': {
        height: '6px',
      },
      '&::-webkit-scrollbar-thumb': {
        backgroundColor: colors.sliderThumb,
        borderRadius: '3px',
      },
    },
    arrayIndex: {
      background: colors.arrayIndexBg,
      color: colors.arrayIndexText,
      padding: '6px 10px',
      borderRadius: '8px',
      fontWeight: '600',
      minWidth: '40px',
      textAlign: 'center',
      flexShrink: 0,
    },
    arrayValueContainer: {
      display: 'flex',
      gap: '8px',
    },
    arrayValue: {
      background: colors.arrayValueBg,
      color: colors.arrayValueText,
      padding: '6px 12px',
      borderRadius: '8px',
      fontWeight: '500',
      minWidth: '50px',
      textAlign: 'center',
      flexShrink: 0,
      boxShadow: colors.arrayValueShadow,
      transition: 'all 0.2s ease',
    },
    arrayValueChanged: {
      background: colors.arrayValueChangedBg,
      color: colors.arrayValueChangedText,
      boxShadow: `0 0 15px ${colors.arrayValueChangedBg}80`,
    },
    arrayValueNew: {
      background: colors.arrayValueNewBg,
      color: colors.arrayValueNewText,
      boxShadow: `0 0 15px ${colors.arrayValueNewBg}80`,
    },
    linkedListContainer: {
      display: 'flex',
      alignItems: 'center',
      gap: '15px',
      overflowX: 'auto',
      paddingBottom: '10px',
    },
    linkedListNode: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      gap: '5px',
      flexShrink: 0,
    },
    linkedListNodeBox: {
      background: colors.linkedListNodeBg,
      color: colors.linkedListNodeText,
      border: `1px solid ${colors.linkedListNodeBorder}`,
      borderRadius: '8px',
      padding: '10px 15px',
      fontWeight: '600',
      boxShadow: colors.linkedListNodeShadow,
      transition: 'all 0.2s ease',
      minWidth: '60px',
      textAlign: 'center',
    },
    linkedListArrow: {
      fontSize: '1.5em',
      color: colors.textSecondary,
    },
    linkedListNull: {
      fontSize: '0.9em',
      color: colors.textSecondary,
      opacity: 0.7,
    },
  };

  // üé® CATEGORIZE VARIABLES
  const categorizedVars = useMemo(() => {
    const categories = {
      arrays: {},
      primitives: {},
      objects: {},
      trees: {},
      graphs: {}
    };

    Object.keys(currentVariables).forEach(key => {
      const value = currentVariables[key];

      if (Array.isArray(value)) {
        categories.arrays[key] = value;
      } else if (typeof value === 'object' && value !== null) {
        const keys = Object.keys(value);

        // Tree detection
        if ((keys.includes('val') || keys.includes('value')) &&
          (keys.includes('left') || keys.includes('right'))) {
          categories.trees[key] = value;
        }
        // Linked List detection
        else if ((keys.includes('val') || keys.includes('data') || keys.includes('value')) &&
          keys.includes('next')) {
          if (!categories.linkedLists) categories.linkedLists = {};
          categories.linkedLists[key] = value;
        }
        // Graph detection
        else if (keys.length > 0 && keys.every(k => Array.isArray(value[k]))) {
          categories.graphs[key] = value;
        }
        // Generic object
        else {
          categories.objects[key] = value;
        }
      } else {
        // Primitives (number, string, boolean)
        categories.primitives[key] = value;
      }
    });

    // üî• SMART DETECTION: Separate stacks and queues from regular arrays
    const smartArrays = {};
    const stacks = {};
    const queues = {};

    Object.keys(categories.arrays).forEach(key => {
      const lowerKey = key.toLowerCase();
      if (lowerKey.includes('stack')) {
        stacks[key] = categories.arrays[key];
      } else if (lowerKey.includes('queue')) {
        queues[key] = categories.arrays[key];
      } else {
        smartArrays[key] = categories.arrays[key];
      }
    });

    categories.arrays = smartArrays;
    categories.stacks = stacks;
    categories.queues = queues;

    return categories;
  }, [currentVariables]);

  // üé® TRACK CHANGES
  const variableStates = useMemo(() => {
    const states = {};
    Object.keys(currentVariables).forEach(key => {
      if (!(key in previousVariables)) {
        states[key] = 'new';
      } else if (JSON.stringify(previousVariables[key]) !== JSON.stringify(currentVariables[key])) {
        states[key] = 'changed';
      } else {
        states[key] = 'unchanged';
      }
    });
    return states;
  }, [currentVariables, previousVariables]);

  useEffect(() => {
    setPreviousVariables(currentVariables);
  }, [stepIndex]);

  const currentStep = traceData[stepIndex];
  if (!currentStep) return <div style={{ color: 'red', padding: '20px' }}>‚ö†Ô∏è Step Error</div>;

  // ‚èØÔ∏è Auto-Play
  useEffect(() => {
    let interval;
    if (isPlaying && stepIndex < traceData.length - 1) {
      interval = setInterval(() => { setStepIndex(prev => prev + 1); }, 800);
    } else { setIsPlaying(false); }
    return () => clearInterval(interval);
  }, [isPlaying, stepIndex, traceData.length]);

  const toggleSection = (section) => {
    setCollapsedSections(prev => ({
      ...prev,
      [section]: !prev[section]
    }));
  };

  const getVariableColor = (state) => {
    switch (state) {
      case 'new': return '#48bb78';
      case 'changed': return '#f6ad55';
      default: return '#4299e1';
    }
  };

  // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
  // üé® RENDERERS
  // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

  const renderTree = (node) => {
    if (!node || typeof node !== 'object') return <span style={styles.nullNode}>null</span>;
    const val = node.val !== undefined ? node.val : (node.value !== undefined ? node.value : null);
    if (val === null) return <span style={styles.nullNode}>x</span>;

    return (
      <div style={{ width: '100%', overflowX: 'auto', display: 'flex', justifyContent: 'center' }}>
        <motion.div
          initial={{ scale: 0, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          transition={{ duration: 0.3 }}
          style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', margin: '0 5px', minWidth: 'fit-content' }}
        >
          <div style={styles.treeNode}>{String(val)}</div>
          {(node.left || node.right) && (
            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
              <div style={{ height: '10px', width: '2px', background: '#666' }}></div>
              <div style={{ display: 'flex', borderTop: '2px solid #666', paddingTop: '5px' }}>
                <div style={{ marginRight: '10px' }}>{renderTree(node.left)}</div>
                <div style={{ marginLeft: '10px' }}>{renderTree(node.right)}</div>
              </div>
            </div>
          )}
        </motion.div>
      </div>
    );
  };

  const renderGraph = (name, graph, state) => (
    <motion.div
      key={name}
      initial={{ y: 20, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      exit={{ y: -20, opacity: 0 }}
      transition={{ duration: 0.4 }}
      style={{
        ...styles.varBox,
        ...styles.glassEffect,
        width: '100%',
        maxWidth: '100%',
        borderColor: getVariableColor(state)
      }}
    >
      <div style={styles.varHeader}>
        <span style={styles.varName}>{name}</span>
        <span style={styles.varType}>Graph</span>
      </div>
      <div style={{ display: 'flex', flexDirection: 'column', gap: '5px', maxWidth: '100%', overflowX: 'auto' }}>
        {Object.keys(graph).map(node => (
          <div key={node} style={styles.graphRow}>
            <div style={styles.graphNode}>{node}</div>
            <div style={{ color: '#666' }}>‚ûî</div>
            <div style={{ display: 'flex', gap: '5px', flexWrap: 'wrap' }}>
              {graph[node] && Array.isArray(graph[node]) ? (
                graph[node].map((neighbor, i) => <div key={i} style={styles.graphNeighbor}>{String(neighbor)}</div>)
              ) : <span style={{ color: '#444', fontSize: '11px' }}>No links</span>}
            </div>
          </div>
        ))}
      </div>
    </motion.div>
  );

  // üî• ENHANCED ARRAY VISUALIZER
  const renderArray = (name, arr, state) => (
    <motion.div
      key={name}
      initial={{ scale: 0.9, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      exit={{ scale: 0.9, opacity: 0 }}
      whileHover={{ scale: 1.02 }}
      transition={{ duration: 0.3 }}
      style={{
        ...styles.enhancedArrayWrapper,
        borderColor: getVariableColor(state),
        boxShadow: state === 'changed' ? `0 0 25px ${getVariableColor(state)}40` : styles.glassEffect.boxShadow
      }}
    >
      {/* Header */}
      <div style={styles.arrayHeader}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <span style={styles.arrayIcon}>üìä</span>
          <div>
            <div style={styles.varName}>{name}</div>
            <div style={{ fontSize: '10px', color: '#888' }}>Length: {arr.length}</div>
          </div>
        </div>
        {state === 'new' && <div style={styles.badge}>NEW</div>}
        {state === 'changed' && <div style={{ ...styles.badge, background: '#f6ad55' }}>CHANGED</div>}
      </div>

      {/* Array Elements */}
      <div style={styles.enhancedArrayContainer}>
        {arr.map((val, idx) => (
          <motion.div
            key={idx}
            initial={{ scale: 0, y: -20 }}
            animate={{ scale: 1, y: 0 }}
            transition={{ delay: idx * 0.05, duration: 0.3, type: 'spring' }}
            style={styles.enhancedArrayItem}
          >
            {/* Index label on top */}
            <div style={styles.arrayIndexTop}>[{idx}]</div>

            {/* Value box */}
            <motion.div
              whileHover={{ scale: 1.1, rotate: 2 }}
              style={{
                ...styles.enhancedArrayBox,
                background: `linear-gradient(135deg, ${getVariableColor(state)}, ${getVariableColor(state)}dd)`
              }}
            >
              {String(val)}
            </motion.div>
          </motion.div>
        ))}
      </div>
    </motion.div>
  );

  // üî• STACK VISUALIZATION (Vertical, bottom-to-top)
  const renderStack = (name, stack, state) => (
    <motion.div
      key={name}
      initial={{ scale: 0.9, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      style={{
        ...styles.enhancedArrayWrapper,
        borderColor: '#f6ad55',
        width: '100%',
        maxWidth: '100%'
      }}
    >
      {/* Header */}
      <div style={styles.arrayHeader}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <span style={{ fontSize: '28px' }}>üìö</span>
          <div>
            <div style={styles.varName}>{name}</div>
            <div style={{ fontSize: '10px', color: '#888' }}>Stack (Size: {stack.length})</div>
          </div>
        </div>
        {state === 'changed' && <div style={{ ...styles.badge, background: '#f6ad55' }}>CHANGED</div>}
      </div>

      {/* Stack items - vertical, bottom to top */}
      <div style={{ display: 'flex', flexDirection: 'column-reverse', gap: '8px', minHeight: '100px' }}>
        <AnimatePresence mode="popLayout">
          {stack.slice(0, 10).map((val, idx) => (
            <motion.div
              key={`${val}-${idx}`}
              initial={{ y: -30, opacity: 0, scale: 0.8 }}
              animate={{ y: 0, opacity: 1, scale: 1 }}
              exit={{ x: 50, opacity: 0, scale: 0.8 }}
              transition={{ duration: 0.4, type: 'spring' }}
              style={{
                ...styles.stackItem,
                background: idx === stack.length - 1
                  ? 'linear-gradient(135deg, #f6ad55, #f59042)'
                  : 'linear-gradient(135deg, #667eea, #764ba2)',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center'
              }}
            >
              <span>{String(val)}</span>
              {idx === stack.length - 1 && (
                <motion.span
                  initial={{ x: -10, opacity: 0 }}
                  animate={{ x: 0, opacity: 1 }}
                  style={{ fontSize: '11px', color: '#fff', fontWeight: 'bold' }}
                >
                  ‚Üê TOP
                </motion.span>
              )}
            </motion.div>
          ))}
        </AnimatePresence>
        {stack.length === 0 && (
          <div style={{ textAlign: 'center', color: '#666', padding: '20px', fontStyle: 'italic' }}>
            Empty Stack
          </div>
        )}
      </div>
    </motion.div>
  );

  // üî• QUEUE VISUALIZATION (Horizontal, left-to-right)
  const renderQueue = (name, queue, state) => (
    <motion.div
      key={name}
      initial={{ scale: 0.9, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      style={{
        ...styles.enhancedArrayWrapper,
        borderColor: '#4299e1',
        width: '100%',
        maxWidth: '100%'
      }}
    >
      {/* Header */}
      <div style={styles.arrayHeader}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <span style={{ fontSize: '28px' }}>üé´</span>
          <div>
            <div style={styles.varName}>{name}</div>
            <div style={{ fontSize: '10px', color: '#888' }}>Queue (Size: {queue.length})</div>
          </div>
        </div>
        {state === 'changed' && <div style={{ ...styles.badge, background: '#4299e1' }}>CHANGED</div>}
      </div>

      {/* Queue items - horizontal */}
      <div style={{ display: 'flex', alignItems: 'center', gap: '10px', overflowX: 'auto', padding: '10px 0' }}>
        <span style={{ fontSize: '11px', color: '#888', fontWeight: 'bold', minWidth: '50px' }}>FRONT ‚Üí</span>

        <div style={{ display: 'flex', gap: '8px' }}>
          <AnimatePresence mode="popLayout">
            {queue.slice(0, 10).map((val, idx) => (
              <motion.div
                key={`${val}-${idx}`}
                initial={{ x: -30, opacity: 0, scale: 0.8 }}
                animate={{ x: 0, opacity: 1, scale: 1 }}
                exit={{ x: 30, opacity: 0, scale: 0.8 }}
                layout
                transition={{ duration: 0.4, type: 'spring' }}
                style={{
                  ...styles.queueItem,
                  background: idx === 0
                    ? 'linear-gradient(135deg, #4fc3f7, #29b6f6)'
                    : 'linear-gradient(135deg, #4299e1, #3182ce)'
                }}
              >
                {String(val)}
              </motion.div>
            ))}
          </AnimatePresence>
        </div>

        <span style={{ fontSize: '11px', color: '#888', fontWeight: 'bold', minWidth: '50px' }}>‚Üê REAR</span>
      </div>

      {queue.length === 0 && (
        <div style={{ textAlign: 'center', color: '#666', padding: '20px', fontStyle: 'italic' }}>
          Empty Queue
        </div>
      )}
    </motion.div>
  );

  // üîó LINKED LIST VISUALIZATION (Horizontal with arrows)
  const renderLinkedList = (name, head, state) => {
    // Traverse linked list and collect nodes (max 10 to prevent infinite loops)
    const nodes = [];
    let current = head;
    const visited = new Set();

    while (current && nodes.length < 10) {
      // Cycle detection
      const nodeId = JSON.stringify(current);
      if (visited.has(nodeId)) {
        nodes.push({ value: '...', isNull: false, isCycle: true });
        break;
      }
      visited.add(nodeId);

      const value = current.val !== undefined ? current.val :
        (current.data !== undefined ? current.data :
          (current.value !== undefined ? current.value : '?'));

      nodes.push({ value, isNull: false, isCycle: false });
      current = current.next;
    }

    const nodeWidth = 100;
    const nodeHeight = 70;
    const arrowGap = 40;
    const totalWidth = nodes.length * (nodeWidth + arrowGap) + 80;

    return (
      <motion.div
        key={name}
        initial={{ scale: 0.9, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        style={{
          ...styles.enhancedArrayWrapper,
          borderColor: '#4fc3f7',
          width: '100%',
          maxWidth: '100%'
        }}
      >
        {/* Header */}
        <div style={styles.arrayHeader}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
            <span style={{ fontSize: '28px' }}>üîó</span>
            <div>
              <div style={styles.varName}>{name}</div>
              <div style={{ fontSize: '10px', color: '#888' }}>Linked List ({nodes.length} nodes)</div>
            </div>
          </div>
          {state === 'changed' && <div style={{ ...styles.badge, background: '#4fc3f7' }}>CHANGED</div>}
        </div>

        {/* SVG Canvas */}
        <svg width={totalWidth} height={nodeHeight + 40} style={{ overflow: 'visible', padding: '20px 10px' }}>
          {/* Define arrow marker */}
          <defs>
            <marker
              id="arrowhead"
              markerWidth="10"
              markerHeight="10"
              refX="9"
              refY="3"
              orient="auto"
              fill="#4fc3f7"
            >
              <polygon points="0 0, 10 3, 0 6" />
            </marker>
          </defs>

          {/* Render nodes and arrows */}
          {nodes.map((node, idx) => {
            const x = idx * (nodeWidth + arrowGap);
            const y = 10;

            return (
              <g key={idx}>
                {/* Node rectangle */}
                <motion.rect
                  initial={{ scale: 0, opacity: 0 }}
                  animate={{ scale: 1, opacity: 1 }}
                  transition={{ delay: idx * 0.1, duration: 0.3 }}
                  x={x}
                  y={y}
                  width={nodeWidth}
                  height={nodeHeight}
                  rx="8"
                  fill="url(#linkedListGradient)"
                  stroke="#4fc3f7"
                  strokeWidth="2"
                />

                {/* Value text */}
                <text
                  x={x + nodeWidth / 2}
                  y={y + nodeHeight / 2 - 5}
                  textAnchor="middle"
                  fill="white"
                  fontSize="16"
                  fontWeight="bold"
                >
                  {String(node.value)}
                </text>

                {/* "next" label */}
                <text
                  x={x + nodeWidth / 2}
                  y={y + nodeHeight - 15}
                  textAnchor="middle"
                  fill="#888"
                  fontSize="10"
                >
                  next ‚Üí
                </text>

                {/* Arrow to next node */}
                {idx < nodes.length - 1 && !node.isCycle && (
                  <motion.line
                    initial={{ pathLength: 0, opacity: 0 }}
                    animate={{ pathLength: 1, opacity: 1 }}
                    transition={{ delay: idx * 0.1 + 0.2, duration: 0.4 }}
                    x1={x + nodeWidth}
                    y1={y + nodeHeight / 2}
                    x2={x + nodeWidth + arrowGap}
                    y2={y + nodeHeight / 2}
                    stroke="#4fc3f7"
                    strokeWidth="3"
                    markerEnd="url(#arrowhead)"
                  />
                )}
              </g>
            );
          })}

          {/* Null indicator at the end */}
          {nodes.length > 0 && !nodes[nodes.length - 1].isCycle && (
            <text
              x={nodes.length * (nodeWidth + arrowGap)}
              y={nodeHeight / 2 + 15}
              fill="#666"
              fontSize="14"
              fontStyle="italic"
            >
              null
            </text>
          )}

          {/* Gradient definition */}
          <defs>
            <linearGradient id="linkedListGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stopColor="#4fc3f7" />
              <stop offset="100%" stopColor="#29b6f6" />
            </linearGradient>
          </defs>
        </svg>

        {nodes.length === 0 && (
          <div style={{ textAlign: 'center', color: '#666', padding: '20px', fontStyle: 'italic' }}>
            Empty List
          </div>
        )}
      </motion.div>
    );
  };

  const renderObject = (name, value, state) => (
    <motion.div
      key={name}
      initial={{ scale: 0.9, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      exit={{ scale: 0.9, opacity: 0 }}
      whileHover={{ scale: 1.02 }}
      transition={{ duration: 0.3 }}
      style={{
        ...styles.varBox,
        ...styles.glassEffect,
        borderColor: getVariableColor(state),
        boxShadow: state === 'changed' ? `0 0 20px ${getVariableColor(state)}40` : styles.glassEffect.boxShadow
      }}
    >
      <div style={styles.varHeader}>
        <span style={styles.varName}>üì¶ {name}</span>
        <span style={styles.varType}>Object</span>
      </div>
      {Object.keys(value).length === 0 ? (
        <div style={{ color: '#666', fontStyle: 'italic' }}>Empty</div>
      ) : (
        Object.keys(value).map(key => (
          <div key={key} style={styles.objectRow}>
            <span style={styles.objKey}>{key}:</span>
            <span style={styles.objValue}>
              {typeof value[key] === 'object' && value[key] !== null
                ? (Array.isArray(value[key]) ? `[${value[key]}]` : '{...}')
                : String(value[key])}
            </span>
          </div>
        ))
      )}
    </motion.div>
  );

  const renderPrimitive = (name, value, state) => (
    <motion.div
      key={name}
      initial={{ scale: 0.8, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      exit={{ scale: 0.8, opacity: 0 }}
      whileHover={{ scale: 1.05 }}
      transition={{ duration: 0.3 }}
      style={{
        ...styles.primitiveBox,
        ...styles.glassEffect,
        borderColor: getVariableColor(state),
        borderWidth: '2px',
        boxShadow: state === 'changed'
          ? `0 0 25px ${getVariableColor(state)}50, 0 4px 15px rgba(0,0,0,0.3)`
          : styles.glassEffect.boxShadow
      }}
    >
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
        <div style={{ ...styles.varName, color: getVariableColor(state) }}>{name}</div>
        {state === 'new' && <div style={styles.badge}>NEW</div>}
        {state === 'changed' && <div style={{ ...styles.badge, background: '#f6ad55' }}>CHANGED</div>}
      </div>
      <motion.div
        animate={{ scale: state === 'changed' ? [1, 1.1, 1] : 1 }}
        transition={{ duration: 0.5 }}
        style={{
          ...styles.primitiveValue,
          color: typeof value === 'number' ? '#4fc3f7' :
            typeof value === 'string' ? '#4ec9b0' :
              typeof value === 'boolean' ? '#dcdcaa' : '#ce9178'
        }}
      >
        {typeof value === 'string' ? `"${value}"` : String(value)}
      </motion.div>
      <div style={{ fontSize: '8px', color: '#666', marginTop: '2px', textTransform: 'uppercase' }}>
        {typeof value}
      </div>
    </motion.div>
  );

  // üéØ SECTION RENDERER
  const renderSection = (title, icon, variables, renderFn, categoryKey) => {
    if (Object.keys(variables).length === 0) return null;

    const isCollapsed = collapsedSections[categoryKey];

    return (
      <motion.div
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        style={styles.section}
      >
        <div
          style={styles.sectionHeader}
          onClick={() => toggleSection(categoryKey)}
        >
          <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
            <span style={{ fontSize: '20px' }}>{icon}</span>
            <span style={styles.sectionTitle}>{title}</span>
            <span style={styles.sectionCount}>{Object.keys(variables).length}</span>
          </div>
          <motion.div
            animate={{ rotate: isCollapsed ? 0 : 90 }}
            transition={{ duration: 0.3 }}
            style={{ fontSize: '16px', color: '#666', cursor: 'pointer' }}
          >
            ‚ñ∂
          </motion.div>
        </div>

        <AnimatePresence>
          {!isCollapsed && (
            <motion.div
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: 'auto', opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              transition={{ duration: 0.3 }}
              style={{ overflow: 'hidden' }}
            >
              <div style={styles.sectionContent}>
                {Object.keys(variables).map(key => renderFn(key, variables[key], variableStates[key] || 'unchanged'))}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    );
  };

  return (
    <div style={styles.container}>
      {/* CONTROLS */}
      <div style={styles.controlBar}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <button onClick={() => setIsPlaying(!isPlaying)} style={styles.playButton}>
            {isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play'}
          </button>
          <div style={{ color: '#aaa', fontSize: '13px' }}>
            Step {stepIndex + 1} / {traceData.length}
          </div>
        </div>
        <input
          type="range"
          min="0"
          max={traceData.length - 1}
          value={stepIndex}
          onChange={(e) => { setIsPlaying(false); setStepIndex(Number(e.target.value)); }}
          style={styles.slider}
        />
        <div style={{ display: 'flex', gap: '5px' }}>
          <button onClick={() => { setIsPlaying(false); setStepIndex(Math.max(0, stepIndex - 1)) }} style={styles.navBtn}>‚óÄ</button>
          <button onClick={() => { setIsPlaying(false); setStepIndex(Math.min(traceData.length - 1, stepIndex + 1)) }} style={styles.navBtn}>‚ñ∂</button>
        </div>
      </div>

      {/* NARRATIVE */}
      <motion.div
        key={`narrative-${stepIndex}`}
        initial={{ opacity: 0, x: -10 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ duration: 0.3 }}
        style={styles.narrative}
      >
        {currentStep.stdout ?
          <span style={{ color: '#4ec9b0' }}>üñ® {currentStep.stdout}</span> :
          <span style={{ color: '#ce9178' }}>‚ö° Line {currentStep.line}: Executing...</span>
        }
      </motion.div>

      {/* CANVAS - CATEGORIZED */}
      <div style={styles.canvasArea}>
        <div style={styles.scopeContainer}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
            <div style={styles.scopeTitle}>VARIABLES & MEMORY</div>
            <button onClick={() => setShowRaw(!showRaw)} style={styles.debugBtn}>
              {showRaw ? 'üî¥ Hide Debug' : 'üîç Debug'}
            </button>
          </div>

          {/* CATEGORIZED SECTIONS */}
          {Object.keys(currentVariables).length > 0 ? (
            <>
              {renderSection('Arrays & Lists', 'üìä', categorizedVars.arrays, renderArray, 'arrays')}
              {renderSection('Stacks', 'üìö', categorizedVars.stacks, renderStack, 'stacks')}
              {renderSection('Queues', 'üé´', categorizedVars.queues, renderQueue, 'queues')}
              {renderSection('Linked Lists', 'üîó', categorizedVars.linkedLists || {}, renderLinkedList, 'linkedLists')}
              {renderSection('Primitives', 'üî¢', categorizedVars.primitives, renderPrimitive, 'primitives')}
              {renderSection('Objects & Dicts', 'üì¶', categorizedVars.objects, renderObject, 'objects')}
              {renderSection('Binary Trees', 'üå≤', categorizedVars.trees,
                (name, value, state) => (
                  <motion.div
                    key={name}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    style={{
                      ...styles.varBox,
                      ...styles.glassEffect,
                      minWidth: 'fit-content',
                      borderColor: getVariableColor(state)
                    }}
                  >
                    <div style={styles.varHeader}>
                      <span style={styles.varName}>üå≤ {name}</span>
                      <span style={styles.varType}>Tree</span>
                    </div>
                    <div style={{ padding: '10px', display: 'flex', justifyContent: 'center' }}>
                      {renderTree(value)}
                    </div>
                  </motion.div>
                ), 'trees'
              )}
              {renderSection('Graphs', 'üï∏Ô∏è', categorizedVars.graphs, renderGraph, 'graphs')}
            </>
          ) : (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              style={{ color: '#666', fontStyle: 'italic', padding: '20px', lineHeight: '1.8', textAlign: 'center' }}
            >
              No variables captured yet.<br />
              <span style={{ color: '#d4d4d4', fontSize: '12px' }}>
                üêç <b>Python Tip:</b> Tracers sometimes ignore top-level code.<br />
                Try wrapping your code in a <code>def main():</code> function.
              </span>
            </motion.div>
          )}

          {/* DEBUG VIEW */}
          {showRaw && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              style={{ marginTop: '20px', ...styles.debugSection }}
            >
              <div style={styles.scopeTitle}>RAW BACKEND DATA</div>
              <pre style={{ color: '#aaa', fontSize: '10px', whiteSpace: 'pre-wrap', marginTop: '10px' }}>
                {JSON.stringify(currentStep, null, 2)}
              </pre>
            </motion.div>
          )}
        </div>
      </div>
    </div>
  );

  // üíÖ ENHANCED STYLES (Theme-aware)
  color: colors.textPrimary,
    fontFamily: 'Inter, sans-serif'
},
  emptyState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '100%',
    background: `linear-gradient(135deg, ${colors.backgroundGradientStart} 0%, ${colors.backgroundGradientEnd} 100%)`
  },
  controlBar: {
    padding: '12px 20px',
    background: colors.inputBg,
    backdropFilter: colors.glassBackdrop,
    borderBottom: `1px solid ${colors.divider}`,
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center'
  },
  playButton: {
    background: `linear-gradient(135deg, ${colors.success}, ${colors.successHover})`,
    color: 'white',
    border: 'none',
    padding: '8px 18px',
    borderRadius: '6px',
    cursor: 'pointer',
    fontWeight: 'bold',
    fontSize: '12px',
    boxShadow: '0 4px 15px rgba(46, 160, 67, 0.3)',
    transition: 'all 0.3s ease'
  },
  navBtn: {
    background: 'rgba(51, 51, 51, 0.6)',
    backdropFilter: 'blur(5px)',
    color: 'white',
    border: '1px solid rgba(255, 255, 255, 0.2)',
    padding: '6px 12px',
    borderRadius: '6px',
    cursor: 'pointer',
    transition: 'all 0.3s ease'
  },
  debugBtn: {
    background: 'transparent',
    border: '1px solid rgba(255, 255, 255, 0.2)',
    color: '#888',
    padding: '5px 12px',
    borderRadius: '6px',
    fontSize: '11px',
    cursor: 'pointer',
    transition: 'all 0.3s ease'
  },
  slider: {
    width: '200px',
    height: '6px',
    borderRadius: '3px',
    outline: 'none',
    background: 'rgba(255, 255, 255, 0.1)',
    cursor: 'pointer'
  },
  narrative: {
    padding: '10px 20px',
    background: 'rgba(30, 30, 30, 0.6)',
    backdropFilter: 'blur(5px)',
    borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
    fontSize: '13px',
    fontFamily: 'monospace'
  },
  canvasArea: {
    flex: 1,
    padding: '20px',
    overflowY: 'auto',
    background: 'transparent',
    maxWidth: '100%',
    width: '100%',
    boxSizing: 'border-box'
  },
  scopeContainer: {
    marginBottom: '20px',
    maxWidth: '100%',
    width: '100%',
    boxSizing: 'border-box'
  },
  scopeTitle: {
    fontSize: '11px',
    color: '#888',
    fontWeight: 'bold',
    letterSpacing: '1.5px',
    textTransform: 'uppercase'
  },

  // üéØ SECTION STYLES
  section: {
    marginBottom: '25px',
    background: 'rgba(255, 255, 255, 0.02)',
    borderRadius: '12px',
    overflow: 'hidden',
    border: '1px solid rgba(255, 255, 255, 0.05)'
  },
  sectionHeader: {
    padding: '15px 20px',
    background: 'rgba(255, 255, 255, 0.03)',
    borderBottom: '1px solid rgba(255, 255, 255, 0.05)',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    cursor: 'pointer',
    transition: 'all 0.3s ease',
    userSelect: 'none'
  },
  sectionTitle: {
    fontSize: '13px',
    fontWeight: 'bold',
    color: '#9cdcfe',
    textTransform: 'uppercase',
    letterSpacing: '1px'
  },
  sectionCount: {
    fontSize: '11px',
    background: 'rgba(0, 122, 204, 0.3)',
    color: '#4fc3f7',
    padding: '2px 8px',
    borderRadius: '10px',
    fontWeight: 'bold'
  },
  sectionContent: {
    padding: '20px',
    display: 'flex',
    flexWrap: 'wrap',
    gap: '15px',
    alignItems: 'flex-start',
    overflowX: 'auto',
    maxWidth: '100%'
  },

  // üåü GLASSMORPHISM
  glassEffect: {
    background: 'rgba(255, 255, 255, 0.05)',
    backdropFilter: 'blur(10px)',
    boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3), 0 0 1px rgba(255, 255, 255, 0.1)',
    border: '1px solid rgba(255, 255, 255, 0.1)',
  },

  varBox: {
    borderRadius: '12px',
    padding: '15px',
    minWidth: '200px',
    maxWidth: '100%',
    transition: 'all 0.3s ease',
    boxSizing: 'border-box'
  },
  varHeader: {
    display: 'flex',
    justifyContent: 'space-between',
    marginBottom: '10px',
    borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
    paddingBottom: '8px'
  },
  varName: {
    color: '#9cdcfe',
    fontWeight: 'bold',
    fontSize: '11px',
    textShadow: '0 0 10px rgba(156, 220, 254, 0.3)'
  },
  varType: {
    color: '#6a9955',
    fontSize: '11px',
    textTransform: 'uppercase',
    letterSpacing: '0.5px'
  },
  badge: {
    padding: '2px 8px',
    background: '#48bb78',
    color: 'white',
    fontSize: '9px',
    borderRadius: '10px',
    fontWeight: 'bold',
    letterSpacing: '0.5px'
  },

  // üî• ENHANCED ARRAY STYLES
  enhancedArrayWrapper: {
    background: 'rgba(255, 255, 255, 0.05)',
    backdropFilter: 'blur(10px)',
    boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3)',
    border: '2px solid rgba(255, 255, 255, 0.1)',
    borderRadius: '16px',
    padding: '15px',
    minWidth: '100%',
  },
  arrayHeader: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: '20px',
    paddingBottom: '15px',
    borderBottom: '2px solid rgba(255, 255, 255, 0.1)'
  },
  arrayIcon: {
    fontSize: '28px',
    filter: 'drop-shadow(0 2px 10px rgba(0, 122, 204, 0.4))'
  },
  enhancedArrayContainer: {
    display: 'flex',
    gap: '15px',
    flexWrap: 'wrap',
    justifyContent: 'center'
  },
  enhancedArrayItem: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: '8px'
  },
  arrayIndexTop: {
    fontSize: '11px',
    color: '#888',
    fontWeight: 'bold',
    fontFamily: 'monospace'
  },
  enhancedArrayBox: {
    minWidth: '50px',
    height: '50px',
    padding: '0 10px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    color: 'white',
    borderRadius: '12px',
    fontWeight: 'bold',
    fontSize: '16px',
    boxShadow: '0 6px 20px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)',
    border: '2px solid rgba(255, 255, 255, 0.3)',
    cursor: 'pointer'
  },

  // OTHER STYLES
  graphRow: {
    display: 'flex',
    alignItems: 'center',
    gap: '10px',
    marginBottom: '5px',
    background: 'rgba(42, 42, 42, 0.6)',
    padding: '8px',
    borderRadius: '6px'
  },
  graphNode: {
    width: '28px',
    height: '28px',
    borderRadius: '50%',
    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
    color: '#fff',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontWeight: 'bold',
    fontSize: '12px',
    boxShadow: '0 4px 10px rgba(102, 126, 234, 0.4)'
  },
  graphNeighbor: {
    padding: '4px 10px',
    background: 'linear-gradient(135deg, #0e639c, #1e7bb3)',
    color: 'white',
    borderRadius: '4px',
    fontSize: '12px',
    boxShadow: '0 2px 8px rgba(14, 99, 156, 0.3)'
  },
  treeNode: {
    width: '35px',
    height: '35px',
    borderRadius: '50%',
    background: 'linear-gradient(135deg, #007acc, #0098ff)',
    color: 'white',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontWeight: 'bold',
    fontSize: '13px',
    zIndex: 10,
    border: '2px solid rgba(0, 122, 204, 0.3)',
    boxShadow: '0 4px 15px rgba(0, 122, 204, 0.5)'
  },
  nullNode: { fontSize: '10px', color: '#555', marginTop: '5px' },
  objectRow: {
    display: 'flex',
    alignItems: 'center',
    borderBottom: '1px solid rgba(255, 255, 255, 0.05)',
    paddingBottom: '6px',
    marginBottom: '6px'
  },
  objKey: {
    color: '#dcdcaa',
    marginRight: '10px',
    minWidth: '30px',
    fontWeight: '600'
  },
  objValue: {
    color: '#ce9178',
    fontFamily: 'monospace'
  },
  primitiveBox: {
    borderRadius: '8px',
    padding: '8px 12px',
    minWidth: '80px',
    maxWidth: '120px',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    transition: 'all 0.3s ease'
  },
  primitiveValue: {
    fontSize: '14px',
    fontWeight: 'bold',
    marginTop: '4px',
    textShadow: '0 2px 10px rgba(255, 255, 255, 0.2)',
    fontFamily: 'monospace'
  },

  // üî• STACK & QUEUE STYLES
  stackItem: {
    padding: '12px 16px',
    borderRadius: '8px',
    color: 'white',
    fontWeight: 'bold',
    fontSize: '14px',
    boxShadow: '0 4px 15px rgba(0, 0, 0, 0.3)',
    border: '2px solid rgba(255, 255, 255, 0.2)',
    minWidth: '100%'
  },
  queueItem: {
    padding: '12px 16px',
    borderRadius: '8px',
    color: 'white',
    fontWeight: 'bold',
    fontSize: '14px',
    boxShadow: '0 4px 15px rgba(0, 0, 0, 0.3)',
    border: '2px solid rgba(255, 255, 255, 0.2)',
    minWidth: '60px',
    textAlign: 'center'
  },

  debugSection: {
    borderTop: '1px solid rgba(255, 255, 255, 0.1)',
    paddingTop: '15px',
    background: 'rgba(0, 0, 0, 0.2)',
    padding: '15px',
    borderRadius: '8px'
  }
  };

// üéØ SECTION RENDERER
const renderSection = (title, icon, variables, renderFn, categoryKey) => {
  if (Object.keys(variables).length === 0) return null;

  const isCollapsed = collapsedSections[categoryKey];

  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      style={styles.section}
    >
      <div
        style={styles.sectionHeader}
        onClick={() => toggleSection(categoryKey)}
      >
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <span style={{ fontSize: '20px' }}>{icon}</span>
          <span style={styles.sectionTitle}>{title}</span>
          <span style={styles.sectionCount}>{Object.keys(variables).length}</span>
        </div>
        <motion.div
          animate={{ rotate: isCollapsed ? 0 : 90 }}
          transition={{ duration: 0.3 }}
          style={{ fontSize: '16px', color: '#666', cursor: 'pointer' }}
        >
          ‚ñ∂
        </motion.div>
      </div>

      <AnimatePresence>
        {!isCollapsed && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.3 }}
            style={{ overflow: 'hidden' }}
          >
            <div style={styles.sectionContent}>
              {Object.keys(variables).map(key => renderFn(key, variables[key], variableStates[key] || 'unchanged'))}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
};

return (
  <div style={styles.container}>
    {/* CONTROLS */}
    <div style={styles.controlBar}>
      <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
        <button onClick={() => setIsPlaying(!isPlaying)} style={styles.playButton}>
          {isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play'}
        </button>
        <div style={{ color: '#aaa', fontSize: '13px' }}>
          Step {stepIndex + 1} / {traceData.length}
        </div>
      </div>
      <input
        type="range"
        min="0"
        max={traceData.length - 1}
        value={stepIndex}
        onChange={(e) => { setIsPlaying(false); setStepIndex(Number(e.target.value)); }}
        style={styles.slider}
      />
      <div style={{ display: 'flex', gap: '5px' }}>
        <button onClick={() => { setIsPlaying(false); setStepIndex(Math.max(0, stepIndex - 1)) }} style={styles.navBtn}>‚óÄ</button>
        <button onClick={() => { setIsPlaying(false); setStepIndex(Math.min(traceData.length - 1, stepIndex + 1)) }} style={styles.navBtn}>‚ñ∂</button>
      </div>
    </div>

    {/* NARRATIVE */}
    <motion.div
      key={`narrative-${stepIndex}`}
      initial={{ opacity: 0, x: -10 }}
      animate={{ opacity: 1, x: 0 }}
      transition={{ duration: 0.3 }}
      style={styles.narrative}
    >
      {currentStep.stdout ?
        <span style={{ color: '#4ec9b0' }}>üñ® {currentStep.stdout}</span> :
        <span style={{ color: '#ce9178' }}>‚ö° Line {currentStep.line}: Executing...</span>
      }
    </motion.div>

    {/* CANVAS - CATEGORIZED */}
    <div style={styles.canvasArea}>
      <div style={styles.scopeContainer}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
          <div style={styles.scopeTitle}>VARIABLES & MEMORY</div>
          <button onClick={() => setShowRaw(!showRaw)} style={styles.debugBtn}>
            {showRaw ? 'üî¥ Hide Debug' : 'üîç Debug'}
          </button>
        </div>

        {/* CATEGORIZED SECTIONS */}
        {Object.keys(currentVariables).length > 0 ? (
          <>
            {renderSection('Arrays & Lists', 'üìä', categorizedVars.arrays, renderArray, 'arrays')}
            {renderSection('Stacks', 'üìö', categorizedVars.stacks, renderStack, 'stacks')}
            {renderSection('Queues', 'üé´', categorizedVars.queues, renderQueue, 'queues')}
            {renderSection('Linked Lists', 'üîó', categorizedVars.linkedLists || {}, renderLinkedList, 'linkedLists')}
            {renderSection('Primitives', 'üî¢', categorizedVars.primitives, renderPrimitive, 'primitives')}
            {renderSection('Objects & Dicts', 'üì¶', categorizedVars.objects, renderObject, 'objects')}
            {renderSection('Binary Trees', 'üå≤', categorizedVars.trees,
              (name, value, state) => (
                <motion.div
                  key={name}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  style={{
                    ...styles.varBox,
                    ...styles.glassEffect,
                    minWidth: 'fit-content',
                    borderColor: getVariableColor(state)
                  }}
                >
                  <div style={styles.varHeader}>
                    <span style={styles.varName}>üå≤ {name}</span>
                    <span style={styles.varType}>Tree</span>
                  </div>
                  <div style={{ padding: '10px', display: 'flex', justifyContent: 'center' }}>
                    {renderTree(value)}
                  </div>
                </motion.div>
              ), 'trees'
            )}
            {renderSection('Graphs', 'üï∏Ô∏è', categorizedVars.graphs, renderGraph, 'graphs')}
          </>
        ) : (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            style={{ color: '#666', fontStyle: 'italic', padding: '20px', lineHeight: '1.8', textAlign: 'center' }}
          >
            No variables captured yet.<br />
            <span style={{ color: '#d4d4d4', fontSize: '12px' }}>
              üêç <b>Python Tip:</b> Tracers sometimes ignore top-level code.<br />
              Try wrapping your code in a <code>def main():</code> function.
            </span>
          </motion.div>
        )}

        {/* DEBUG VIEW */}
        {showRaw && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            style={{ marginTop: '20px', ...styles.debugSection }}
          >
            <div style={styles.scopeTitle}>RAW BACKEND DATA</div>
            <pre style={{ color: '#aaa', fontSize: '10px', whiteSpace: 'pre-wrap', marginTop: '10px' }}>
              {JSON.stringify(currentStep, null, 2)}
            </pre>
          </motion.div>
        )}
      </div>
    </div>
  </div>
);
};

export default Canvas;
```